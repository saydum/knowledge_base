# Массивы и срезы

## Массивы
Массив — это последовательность элементов одного типа фиксированной длины.

```GO
var a [3]int
fmt.Println(a) // [0 0 0 ]
```

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):
```GO
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```
Вместо явного указания длины массива мы можем указать символ многоточия (...) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений

`Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию`

### Сравнение массивов
Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:
```GO
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```
`Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).`

### Обращение к элементам массива. Индексы
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}
```
При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:
`Range возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента.`
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив. В этом случае мы должны обращаться к элементам массива по индексу:
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

---
## Срезы (слайсы, slices)

### Понятие среза
Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива.
Длина и емкость среза могут быть определены при помощи встроенных функций len() и cap() соответственно.

### Создание среза
make() - Функция для создания среза
`make([]Type, length, capacity)`
```GO
a := make([]int, 10, 10)
```

### Оператор среза
Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s).
При этом должно соблюдаться условие 0 <= i <= j <= cap(s).
```GO
users := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}

us1 := users[2:6] // с 3-го по 6-й
us2 := users[:4] // с 1-го по 4-й
us3 := users[3:] // с 4-го до конца

fmt.Println(us1) // [Kate Sam Tom Paul]
fmt.Println(us2) // [Bob Alice Kate Sam]
fmt.Println(us3) // [Sam Tom Paul Mike Robert]
```

### Встроенные функции для работы со срезами
Для работы со срезами в Go предусмотрены встроенные функции append и copy.

Функция append позволяет добавить в срез новый элемент, выглядит она следующим образом:
`функция append(slice []Type, elems ...Type) []Type`

#### Использование append для удаления элемента из среза
В GO отсутствует функция для удаления элемента из среза, но можнот воспользоваться функцией append для того чтоб создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:
```GO
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

#### Функция copy - копирование элементов среза
Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:
```GO
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```
#### Особенности работы со срезами
