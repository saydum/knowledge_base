# Массивы и срезы

## Массивы
Массив — это последовательность элементов одного типа фиксированной длины.

```GO
var a [3]int
fmt.Println(a) // [0 0 0 ]
```

Одновременно с объявлением массива мы можем задать значения его элементов (инициализировать его):
```GO
var a [3]int = [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [...]int{1, 2, 3}
d := [3]int{1: 12}

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [1 2 3]
fmt.Println(c) // [1 2 3]
fmt.Println(d) // [0 12 0]
```
Вместо явного указания длины массива мы можем указать символ многоточия (...) в квадратных скобках, тогда длина массива будет определена Go в зависимости от количества указанных при инициализации значений

`Несмотря на то, что такой вариант допустим, он не считается идиоматичным для Go и не рекомендуется к использованию`

### Сравнение массивов
Поскольку мы можем последовательно сравнить все элементы массива, мы можем сравнить и сами массивы:
```GO
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{3, 2, 1}

fmt.Println(a == b) // true
fmt.Println(a == c) // false
```
`Но при этом нужно учитывать, что сравнимы только массивы одного типа (массивы одинаковой длины, содержащие элементы одинакового типа).`

### Обращение к элементам массива. Индексы
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
	// 1
	// 2
	// 3
	// 4
	// 5
}
```
При итерации по массиву мы можем использовать ключевое слово range, тогда цикл будет иметь следующий вид:
`Range возвращает 2 объекта: индекс элемента в массиве и копию значения этого элемента.`
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for idx, elem := range a {
    fmt.Printf("Элемент с индексом %d: %d\n", idx, elem)
    // Элемент с индексом 0: 1
    // Элемент с индексом 1: 2
    // Элемент с индексом 2: 3
    // Элемент с индексом 3: 4
    // Элемент с индексом 4: 5
}
```

Необходимо запомнить, что в качестве второго значения range возвращает копию элемента массива, это может быть важно, если в цикле мы хотим изменить массив. В этом случае мы должны обращаться к элементам массива по индексу:
```GO
a := [5]int{1, 2, 3, 4, 5}
fmt.Println(a) // [1 2 3 4 5]

for _, elem := range a {
    elem = 100
    fmt.Println(elem)

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [1 2 3 4 5]

for idx := range a {
    a[idx] = 100
    fmt.Println(a[idx])

    // 100
    // 100
    // 100
    // 100
    // 100
}
fmt.Println(a) // [100 100 100 100 100]
```

---
## Срезы (слайсы, slices)

### Понятие среза
Срез — это структура данных, которая предоставляет доступ к подпоследовательности элементов базового массива.
Длина и емкость среза могут быть определены при помощи встроенных функций len() и cap() соответственно.

### Создание среза
make() - Функция для создания среза
`make([]Type, length, capacity)`
```GO
a := make([]int, 10, 10)
```

### Оператор среза
Оператор среза s[i:j] создает из последовательности s новый срез, который содержит элементы последовательности s с i по j-1. При этом должно соблюдаться условие 0 <= i <= j <= cap(s).
При этом должно соблюдаться условие 0 <= i <= j <= cap(s).
```GO
users := [8]string{"Bob", "Alice", "Kate", "Sam", "Tom", "Paul", "Mike", "Robert"}

us1 := users[2:6] // с 3-го по 6-й
us2 := users[:4] // с 1-го по 4-й
us3 := users[3:] // с 4-го до конца

fmt.Println(us1) // [Kate Sam Tom Paul]
fmt.Println(us2) // [Bob Alice Kate Sam]
fmt.Println(us3) // [Sam Tom Paul Mike Robert]
```

### Встроенные функции для работы со срезами
Для работы со срезами в Go предусмотрены встроенные функции append и copy.

Функция append позволяет добавить в срез новый элемент, выглядит она следующим образом:
`функция append(slice []Type, elems ...Type) []Type`

#### Использование append для удаления элемента из среза
В GO отсутствует функция для удаления элемента из среза, но можнот воспользоваться функцией append для того чтоб создать новый срез, включающий в себя срез элементов до игнорируемого элемента, а также все элементы после игнорируемого:
```GO
a := []int{1, 2, 3, 4, 5, 6, 7}
a = append(a[0:2], a[3:]...)
fmt.Println(a) // [1 2 4 5 6 7]
```

#### Функция copy - копирование элементов среза
Copy принимает срез-назначение и срез источник, а возвращает число скопированных элементов:
```GO
a := []int{1, 2, 3}
b := make([]int, 3, 3)
n := copy(b, a)

fmt.Printf("a = %v\n", a)                  // a = [1 2 3]
fmt.Printf("b = %v\n", b)                  // b = [1 2 3]
fmt.Printf("Скопировано %d элемента\n", n) // Скопировано 3 элемента
```
##### Задача 1

```Go
/*
На первом этапе на стандартный ввод подается 10 целых положительных чисел, которые должны быть записаны в порядке ввода в массив из 10 элементов. Тип чисел, входящих в массив, должен соответствовать минимально возможному целому беззнаковому числу. Имя массива который вы должны сами создать workArray (условие обязательное). Для чтения из стандартного ввода уже импортирован пакет fmt.

На втором этапе на стандартный ввод подаются еще 3 пары чисел - индексы элементов этого массива, которые требуется поменять местами (если такая пара чисел 3 и 7, значит в массиве элемент с 3 индексом нужно поменять местами с элементом, индекс которого 7).

Элементы полученного массива должны быть выведены через пробел на стандартный вывод. Далее автоматически будет проведена проверка используемых типов, результат которой будет добавлен к вашему ответу.

Использование массива - обязательное условие!

Sample Input:

99 151 137 71 117 187 20 93 187 67 1 2 3 5 7 8
Sample Output:

99 137 151 187 117 71 20 187 93 67 type ok
*/
var workArray[10]uint8
for i := 0; i < 10; i++ {
    fmt.Scan(&workArray[i])
}
var a uint8
var b uint8

for i := 0; i < 3; i++ {
    fmt.Scan(&a, &b)
    workArray[a],workArray[b] = workArray[b],workArray[a]
}

for _, elem := range workArray {
    fmt.Print(elem, " ")
}
```

##### Задача 2
```GO
/*
Напишите программу, принимающая на вход число N (N \geq 4)N(N≥4), а затем NN целых чисел-элементов среза. На вывод нужно подать 4-ый (3 по индексу) элемент данного среза.

Sample Input:

5
41 -231 24 49 6
Sample Output:

49
*/
    var sl, in, res int
    fmt.Scan(&sl)
    sr := make([]int, sl)
    for i := 0; i < sl; i++ {
        fmt.Scan(&in)
        sr = append(sr, in)
    }
    sr = append(sr[:0], sr[sl:]...)

    for _, elem := range sr[3:4] {
        res = elem
    }
    fmt.Print(res)
```

##### Задача 3
```GO
```

##### Задача 4
```GO
```

##### Задача 5
```GO
```
